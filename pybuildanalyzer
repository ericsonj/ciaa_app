#!/usr/bin/env python3

import re
import argparse
import sys
from pathlib import Path

usingColor = False

def toKB(num):
    if num < 1024:
        return '{}B'.format(num)
    return '{:.2f}K'.format(num/1024)

class Symbol:
    def __init__(self, addr, size, t, name, linenum=None):
        self.addr = int(f"0x{addr}", 16)
        self.size = int(f"0x{size}", 16)
        self.type = t
        self.name = name
        self.linenum = linenum
    
    def __repr__(self):
        name = str(self.name)
        addr = hex(self.addr)
        size = str(self.size)
        t = str(self.type)
        linenum = str(self.linenum)
        return f"{name}, {t}, {addr}, {size}, {linenum}"

class SectionHeader:
    def __init__(self, name, addr, length, loadAddr=0):
        self.name = name
        self.addr = addr
        self.loadAddr = loadAddr
        self.length = length

    def __str__(self):
        return self.name + ' ' + hex(self.addr) + ' ' + hex(self.length) + ' ' + hex(self.loadAddr)

    def __repr__(self):
        return self.name + ' ' + hex(self.addr) + ' ' + hex(self.length) + ' ' + hex(self.loadAddr)

class MemRegion:

    PRINT_FORMAT = '| {0:<12}| {1:<15}| {2:<15}| {3:<9}| {4:<9}| {5:<9} {6:<11} {7:>7} |'

    def __init__(self, name, attr, origin, length):
        self.name = name
        self.attr = attr
        self.origin = origin
        self.length = length
        self.end = origin + length
        self.using = 0

    @staticmethod
    def factory(d: dict):
        name = d['name']
        attr = d['attr']
        origin = int(d['origin'], 16)
        length = int(d['length'], 16)
        return MemRegion(name, attr, origin, length)

    def __str__(self):
        return self.name + ' ' + self.attr + ' ' + hex(self.origin) + ' ' + hex(self.end) + ' ' + hex(self.length) + ' ' + hex(self.using)

    def __repr__(self):
        return self.name + ' ' + self.attr + ' ' + hex(self.origin) + ' ' + hex(self.end) + ' ' + hex(self.length) + ' ' + hex(self.using)

    def printStats(self):
        if (self.length == 0):
            return MemRegion.PRINT_FORMAT.format(
                        self.name,
                        hex(self.origin),
                        hex(self.end),
                        '0.0K',
                        '0.0K',
                        '0.0K',
                        printBar(10, 0, usingColor=usingColor),
                        '{:.2f}%'.format(0.0)
            )
        name = self.name
        origin = hex(self.origin)
        end = hex(self.end)
        length = toKB(self.length)
        free = toKB(self.length - self.using)
        using = toKB(self.using)
        bar = printBar(self.length, self.using, usingColor=usingColor)
        perc = '{:.2f}%'.format((self.using/self.length)*100)
        return MemRegion.PRINT_FORMAT.format(name, origin, end, length, free, using, bar, perc)


def printBar(total, using, length=10, usingColor=False):
    str = []
    if total == 0:
        total = 1
        using = 0
    str.append('|')
    rate = using/total
    color = '\033[91m'
    if rate < 0.60:
        color = '\033[92m'
    elif rate < 0.90:
        color = '\033[93m'
    if usingColor:
        str.append(color)
    unit = total/length
    uunit = unit/8
    a = int(using/uunit)
    b = int(a/8)
    c = a - b*8
    str.append(chr(9608)*b)
    if c > 0: 
        str.append(chr(9615 - (1*c)))
    s = b + (1 if c > 0 else 0)
    str.append(' '*(length-s))
    if usingColor:
        str.append('\033[0m')

    str.append('|')
    return ''.join(str)

#
# ---- Main ----
#

parser = argparse.ArgumentParser(description='Builder Analyzer for ARM firmware')
parser.add_argument('mapfile', type=str, help='Map file .map')
parser.add_argument('-c', '--color', action='store_true')
parser.add_argument('-s', '--symbolsfile', type=str, help='Symbols list file, ex: nm -nAsSCpl a.out > a.symls')
parser.add_argument('-a', '--all', action='store_true', help='Complete analysis of symbols and regions, need --symbols-file')
parser.add_argument('-v', '--version', action='version', version='%(prog)s 1.0.1')
args = parser.parse_args()

mapfile = args.mapfile
if args.color:
    usingColor = True

memlines = False
memNewLines = 2
maplines = False
mapNewLines = 2
readStackSize = False

mapfile = open(mapfile, 'r')
content = []
readNextLine = False
upstream = []
for line in mapfile:

    if (re.match(r'^Memory Configuration', line)):
        memlines = True

    if memlines:
        if (line.strip() == ''):
            memNewLines = memNewLines - 1
        if memNewLines == 0:
            memlines = False
        line = line.strip()
        line = re.sub(r'\s+', ' ', line)
        content.append(line)

    if re.match(r'^[.].*', line):
        if not ' ' in line.strip():
            readNextLine = True
        upstream.append(line.strip())
    else:
        if readNextLine:
            upstream[-1] = upstream[-1] + ' ' + line.strip()
            readNextLine = False
mapfile.close()

if args.all:
    if not args.symbolsfile:
        print('Set symbols file')
        exit(-1)

if args.symbolsfile and not Path(args.symbolsfile).exists():
    print('Not found symbols file')
    exit(-1)

p = re.compile(r'^[.][a-zA-Z\\.0-9_-]+\s+0x[0-9a-fA-F]+\s+0x[0-9a-fA-F]+.*')
upstream = list(filter(p.search, upstream))
sections = []
lines = upstream
p = re.compile(
    r'^(?P<name>[.][a-z-A-Z\\.0-9_-]+)\s+(?P<addr>[0-9xa-fA-F]+)+\s+(?P<length>[0-9xa-fA-F]+).*')
p2 = re.compile(
    r'^(?P<name>[.][a-z-A-Z\\.0-9_-]+)\s+(?P<addr>[0-9xa-fA-F]+)+\s+(?P<length>[0-9xa-fA-F]+)\s+load\s+address\s+(?P<load_addr>[0-9xa-fA-F]+).*')
for l in lines:
    m = None
    loadAddr = 0
    if 'load' in l:
        m = p2.search(l)
        loadAddr = int(m.group('load_addr'), 16)
    else:
        m = p.search(l)

    if m:
        name = m.group('name')
        addr = int(m.group('addr'), 16)
        length = int(m.group('length'), 16)
        sections.append(SectionHeader(name, addr, length, loadAddr))

for line in content:
    if re.match(r'^Memory Configuration', line):
        content.remove(line)
    elif re.match(r'^Name\s+Origin\s+Length\s+Attributes', line):
        content.remove(line)
    elif re.match(r'^[*]default[*].*', line):
        content.remove(line)

regions = []
for regin in content:
    values = regin.split(' ')
    try:
        regions.append(MemRegion(
            name=values[0],
            attr=values[3],
            origin=int(values[1], 16),
            length=int(values[2], 16)
        ))
    except:
        pass


for r in regions:
    for s in sections:
        if ( s.addr >= r.origin and s.addr < r.end):
            r.using = r.using + s.length
        elif (s.name == '.data' and (s.loadAddr >= r.origin and s.loadAddr < r.end)):
            r.using = r.using + s.length

symbols = []
if args.symbolsfile:
    symbfile = open(args.symbolsfile)
    regex = r".*:(?P<addr>[0-9a-f]+)[ ]+(?P<size>[0-9a-f]+)[ ]+(?P<type>[a-zA-Z]+)[ ]+(?P<name>[a-zA-Z0-9_-]+)[ ]*(?P<linenum>.*$)"
    for l in symbfile:
        match = re.search(regex, l)
        if match:
            symbols.append(
                Symbol(
                    match.group('addr'),
                    match.group('size'),
                    match.group('type'),
                    match.group('name'),
                    match.group('linenum')
                )
            )

if args.all:
    for r in regions:
        print("{0} {1}".format(r.name, r.using))
        count = 0
        for s in sections:
            if ( (s.addr >= r.origin and s.addr < r.end and s.length > 0) or (s.name == '.data' and (s.loadAddr >= r.origin and s.loadAddr < r.end))):
                print("\t{0:16} {1} {2} {3}".format(s.name, hex(s.addr), hex(s.loadAddr), s.length))
                for sym in symbols:
                    if (sym.addr >= r.origin and sym.addr < r.end and s.name == '.text' and (sym.type == 't' or sym.type == 'T')):
                        print("\t\t{0:40} {1:4} {2} {3}".format(sym.name, sym.size, sym.type, hex(sym.addr)))
                    elif (sym.addr >= r.origin and sym.addr < r.end and s.name == '.bss' and (sym.type == 'b' or sym.type == 'B')):
                        print("\t\t{0:40} {1:4} {2} {3}".format(sym.name, sym.size, sym.type, hex(sym.addr)))
                    elif (s.name == '.data'):
                        if (sym.addr >= s.addr and sym.addr < (s.addr + s.length) and (sym.type == 'd' or sym.type == 'D')):
                            print("\t\t{0:40} {1:4} {2} {3}".format(sym.name, sym.size, sym.type, hex(sym.addr)))

                # elif (s.name == ".data" and (sym.type == 'd' or sym.type == 'D') and ((s.loadAddr >= r.origin and s.loadAddr < r.end) or (sym.addr >= s.addr and sym.addr < (s.addr + s.length)))):
                #     print("\t\t{0:40} {1:4} {2} {3}".format(sym.name, sym.size, sym.type, hex(sym.addr)))

        # for sym in symbols:
        #     if (sym.addr >= r.origin and sym.addr < r.end):
        #         count += sym.size
        #         print("\t\t{0:32} {1:4} {2}".format(sym.name, sym.size, sym.type))

        print("\tTotal: {0}".format(count))

    print(MemRegion.PRINT_FORMAT.format('Region', 'Start', 'End', 'Size', 'Free', 'Used', '', 'Usage(%)'))
    for r in regions:
        print(r.printStats())


